<a name="intro"></a>

### Введение

**Данный документ** представляет собой справочное руководство по шаблонизатору BEMHTML.

В документе описаны:

* основные особенности BEMHTML, отличающие его от других шаблонизаторов;
* примеры решения типовых задач средствами BEMHTML.

**Целевая аудитория документа** — веб-разработчики и HTML-верстальщики, использующие
[БЭМ-методологию](http://ru.bem.info/method/).

Предполагается, что читатель знаком с:

* HTML;
* JavaScript;
* CSS;
* БЭМ;
* [BEMJSON](../bemjson/bemjson.ru.md).


**В документе не описаны** настройка среды разработки и процедуры компиляции шаблонов, синтаксис BEM-XJST-шаблонизаторов, синтаксис BEMJSON.

<a name="bemhtml"></a>

### Особенности шаблонизатора BEMHTML

<a name="arch"></a>
####Архитектура шаблонизатора

Для обработки BEMHTML-шаблонов используется модуль [bem-xjst](https://github.com/bem/bem-xjst), расширенный логикой из базового шаблона BEMHTML – [i-bem.bemhtml](https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.bemhtml).

Специфическая для BEMHTML логика при этом реализована на уровне базового шаблона `i-bem.bemhtml`. Базовый шаблон определяет:
* набор и порядок вызова [стандартных мод](#standardmoda);
* доступные [поля контекста](#context_field)

Подробнее об особенностях архитектуры BEMHTML читайте в разделе [архитектура шаблонизаторов BEMHTML и BEMTREE](../templating/template.ru.md#uts_arch) документа по [шаблонизации данных в bem-core](../templating/template.ru.md).

<a name="uts"></a>
####Поддержка BEM-XJST-синтаксиса
BEMHTML – [BEM-XJST-шаблонизатор](../templating/template.ru.md#uts_intro). Иначе говоря, BEMHTML использует **BEM-XJST-синтаксис** и сохраняет все особенности BEM-XJST-шаблонизаторов, такие как:
* [привязка к БЭМ-предметной области](../templating/template.ru.md#bem_area);
* [декларативные шаблоны](../templating/template.ru.md#decl_templatе);
* [язык описания и исполнения шаблонов — JavaScript](../templating/template.ru.md#language);
* [ограничения на уровне соглашений](../templating/template.ru.md#restrictions).



<a name="basic"></a>

### Основные понятия

<a name="inputdata"></a>

#### Входные данные: BEMJSON

Поскольку BEMHTML основан на JavaScript, стандартным форматом представления БЭМ-дерева выбрана структура данных (объект) JavaScript, с набором дополнительных соглашений о представлении БЭМ-сущностей — BEMJSON.


Задача шаблонизатора BEMHTML — преобразовать входное БЭМ-дерево в выходной HTML-документ. В целях сохранения гибкости
и поддерживаемости, на уровне шаблонизатора не следует производить сложных преобразований входных данных. Шаблоны должны
быть максимально простыми утверждениями, сопоставляющими каждому типу БЭМ-сущности нужное HTML-оформление.

Поэтому структура входного БЭМ-дерева должна быть ориентирована на **представление** (view), чтобы при генерации
HTML-дерева не требовалось изменять набор и порядок блоков и элементов. Приведение БЭМ-дерева к такому развернутому виду должно производиться на уровне бэкенда, предшествующего шаблонизатору (например, с помощью технологии [BEMTREE](../bemtree/bemtree-reference.ru.md/)). 

Иллюстрацией view-ориентированного формата
данных может служить пример френдленты, разобранный в разделе [Приведение входных данных к формату, ориентированному на представление](../bemtree/bemtree-reference.ru.md#bringing_input) документации по BEMTREE.

В то же время детали организации HTML-страницы, которые являются зоной ответственности верстальщика, должны определяться
только на уровне шаблонизатора. Пример такого решения приведен в разделе [Добавление БЭМ-сущностей для задач верстки](#additionbem).

**См. также**:

  * [Синтаксис BEMJSON]((../bemjson/bemjson.ru.md)


<a name="templatebemjson"></a>

#### Шаблон

Единицей программы на BEMHTML является **шаблон**. Шаблон BEMHTML связывает входную БЭМ-сущность (заданную именем
сущности, элемента, именем и значением модификатора) и соответствующий этой сущности HTML-элемент.

Шаблон состоит из:

* **предиката** — набора условий, при выполнении которых применяется шаблон. Типичный предикат описывает свойства
  входной БЭМ-сущности;
* и **тела** — инструкций по генерации выходного HTML.

**См. также**:

* [Синтаксис BEMHTML](#bemhtml)

<a name="moda"></a>

#### Мода

В процессе работы шаблонизатор последовательно обходит узлы входного БЭМ-дерева. Для каждого узла — БЭМ-сущности —
выполняется цикл генерации выходного HTML-элемента. Для вложенных сущностей цикл генерации HTML-элементов выполняется
рекурсивно. Таким образом, выходное HTML-дерево формируется поэлементно в процессе обхода входного БЭМ-дерева.

Цикл генерации каждого элемента последовательно проходит ряд фаз, называемых **модами**. Каждая мода отвечает
за определенный фрагмент генерируемого HTML-элемента — тег, атрибуты, класс и т.п. В каждой моде вызывается процедура выбора и выполнения подходящего шаблона.

Моды позволяют разделить выходной элемент на фрагменты, каждый из которых может быть описан простым типом данных:
тег и класс — строкой, атрибуты — словарем, необходимость в БЭМ-классах — логическим значением и т.п. Благодаря этому
возможно написание декларативных шаблонов, в предикате которых указана мода, а в теле содержатся данные соответствующего
этой моде простого типа. В этом случае полное представление HTML-элемента может быть задано несколькими шаблонами.

Особый статус имеет **[мода default](#default)**, которая отвечает за генерацию целого HTML-элемента. В рамках этой
моды задан набор и порядок прохождения остальных мод, соответствующих фрагментам HTML-элемента, а также определена
процедура сборки финального представления HTML-элемента из фрагментов, сгенерированных в остальных модах. Написание
шаблона, который переопределяет поведение в данной моде, позволяет полностью контролировать генерацию элемента
из BEMHTML, не пользуясь стандартными модами, позволяющими генерировать выходной элемент по частям.

**См. также**:

* [Стандартные моды](#standardmoda)

<a name="context"></a>

#### Контекст

В процессе обхода входного BEMJSON-дерева шаблонизатор строит **контекст** — структуру данных, которая доступна в момент применения шаблонов. Контекст соответствует текущему элементу (узлу) входного БЭМ-дерева и включает:

* нормализованные сведения о текущей БЭМ-сущности;
* фрагмент входных данных без модификаций (текущий элемент BEMJSON-дерева и его потомки);
* строковый буфер, в который записывается HTML-результат;
* служебные поля, содержащие сведения о текущем состоянии (мода, позиция во входном БЭМ-дереве и т.п.);
* вспомогательные функции.

БЭМ-сущность, описываемая текущим контекстом, называется **контекстной сущностью**.

**См. также**:

* [Поля контекста](#context_field)
* [Достраивание БЭМ-сущностей по контексту](../templating/template.ru.md#extensionbem)



<a name="standardmoda"></a>

### Стандартные моды

В базовом шаблоне BEMHTML определен набор стандартных мод, которые задают порядок обхода входного БЭМ-дерева (BEMJSON) и генерации выходного HTML, используемый BEMHTML по умолчанию.

По функциональности моды разделяются на два класса:

  * **«Пустая» мода** определяет алгоритм обхода узлов входного BEMJSON и вызова остальных мод;
  * Все остальные моды определяют порядок генерации выходного HTML. В каждой из таких мод формируется тот или иной
    фрагмент выходного HTML-дерева.

Для генерации HTML в каждой моде вызывается процедура выбора и выполнения подходящего шаблона (предикат которого истинен
в данном контексте). Результат вычисления тела выбранного шаблона подставляется в тот фрагмент HTML-дерева (HTML-элемента), за генерацию которого отвечает данная мода.

Данная логика работы накладывает следующие ограничения на шаблоны:

  * Если шаблон выводит какие-то данные в HTML, в его предикате должна быть указана мода.
  * В предикате шаблона может быть указано не более одной моды.
  * В результате вычисления тела шаблона должен возвращаться тот тип объекта, который ожидается в рамках данной моды.

В последующих разделах моды перечислены в порядке их вызова при обработке элемента входного BEMJSON.

<a name="empty_moda"></a>

#### «Пустая» мода (`""`)

*Тип значения тела шаблона: `не используется`*

Пустая (не определенная) мода соответствует моменту, когда значение поля контекста `this._mode` равно пустой стоке
(`""`). Это значение выставляется:

  * перед началом обработки входного дерева;
  * в момент рекурсивного вызова процедуры обхода дерева в моде `default`.

Действие, выполняемое в рамках пустой моды, зависит от типа контекстного (текущего) элемента входного BEMJSON-дерева.

<table>
<tr>
    <th>Тип элемента</th>
    <th>Действие</th>
</tr>
<tr>
    <td><b>БЭМ-сущность</b>(блок или элемент)</td>
    <td>Выставление значений в служебных полях контекста (<code>block elem mods elemMods ctx position</code>)
    и вызов шаблонов по моде <code>default</code>.</td>
</tr>

<tr>
    <th>строка/число</th>
    <td>Вывод значения, приведенного к строке, в буфер HTML-результата.</td>
</tr>
<tr>
    <th>Boolean, undefined, null</th>
    <td>Вывод пустой строки в буфер HTML-результата.</td>
</tr>
<tr>
    <th>массив</th>
    <td>Итерация по массиву с рекурсивным вызовом шаблонов по пустой моде.</td>
</tr>
</table>

Определение шаблона по пустой моде (подпредикат `mode(this._mode === "")`) имеет смысл только в том случае, если необходимо
переопределить принцип обхода входного дерева.

Вызов шаблонов по пустой моде (конструкция `apply('')` в теле шаблона) необходим, если требуется отклониться
от однозначного соответствия «входная БЭМ-сущность — выходной HTML-элемент» и сгенерировать более одного элемента на одну входную сущность. В частности, такой вызов осуществляется автоматически при использовании
[конструкции applyCtx](../templating/template.ru.md#applyctx).

**См. также**:

  * [Оборачивание блока в другой блок](#wrappingunit)

<a name="default"></a>

#### default

*Тип значения тела шаблона: `не используется`*

В рамках моды `default` полностью формируется выходной HTML-элемент, соответствующий входной БЭМ-сущности.

В ходе выполнения моды `default` происходит:

  * вызов всех остальных стандартных мод, отвечающих за формирование отдельных аспектов HTML-элемента;
  * объединение результатов выполнения всех вызываемых мод в результирующую HTML-строку;
  * рекурсивный вызов шаблонов на результат выполнения моды `content`.

На рисунке ниже схематически отражено, в каких модах генерируются различные фрагменты выходного HTML-элемента.

![mode-default](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_default.png)

Схема отражает вариант обработки элемента, имеющего пару открывающий—закрывающий тег и вложенное содержимое. Обработка
коротких (самозакрытых) элементов аналогична и отличается только отсутствием закрывающего тега и рекурсии. Следует
ли обрабатывать данный элемент как короткий, определяет вспомогательная функция контекста `this._.isShortTag`
на основании имени элемента (тега).

Определение шаблона по моде `default` (подпредикат `def()`) необходимо в тех случаях, когда нужно переопределить
процедуру генерации выходного HTML-элемента, например, добавить DOCTYPE к тегу HTML:


```js
block ('b-page')(
  def()(
    this._buf.push('<!DOCTYPE html>');
    applyNext();
  ),
  tag()('html')
)
```


<a name="tag"></a>

#### tag

* *Тип значения тела шаблона: `String`*
* *Значение по умолчанию: `` 'div' ``*

Мода `tag` задает имя выходного HTML-элемента (тег). По умолчанию имя элемента равно `div`. Фрагменты HTML, за генерацию
которых отвечает мода `tag`, выделены на рисунке:

![mode-tag](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_tag.png)

***
**NB** Если в качестве значения `tag` указать пустую строку, для данной сущности будет пропущен этап генерации
HTML-элемента (тега и всех атрибутов), но содержимое элемента (`content`) будет обработано обычным образом.
***

Определение шаблона по моде `tag` (подпредикат `tag()`) необходимо, если:

  * для данной сущности следует сгенерировать HTML-элемент с именем, отличным от `div`;
  * отказаться от генерации HTML-элемента для данной сущности, но обработать вложенные сущности.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'b1',
  content: 'text'
}</code></pre>
    </td>
    <td><pre><code>block('b1').tag()('span')</code></pre></td>
    <td><pre><code>&lt;span class="b1"&gt;text&lt;/span&gt;</code></pre></td>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1',
  content: {
    block: 'b2'
  }
}</code></pre>
    </td>
    <td><pre><code>block('b1').tag()('')</code></pre></td>
    <td><pre><code>&lt;div class="b2"&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>

<a name="js"></a>

#### js

* *Тип значения тела шаблона: `Boolean|Object`*
* *Значение по умолчанию: `false`*

Мода `js` указывает, есть ли у обрабатываемого блока клиентский JavaScript. В случае наличия JavaScript в моде `js`
могут быть переданы параметры клиентского JavaScript (записываются в атрибут HTML-элемента, имя которого определяется
[модой `jsAttr`](#jsattr).

Мода `js` допускает два типа значения тела шаблона:

  * `Boolean` — Флаг, указывающий, имеет ли данный блок клиентский JavaScript.
  * `Object` — Хэш, содержащий параметры JavaScript (подразумевается, что данный блок имеет клиентский JavaScript).

Фрагменты HTML, за генерацию которых отвечает мода `js`, выделены на рисунке:

![mode-js](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_js.png)

Определение шаблона по моде `js` (подпредикат `js()`) имеет смысл только в том случае, если у блока имеется клиентский
JavaScript.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td><pre><code>{block: 'b1'}</code></pre></td>
    <td><pre><code>block('b1').js()(true)</code></pre></td>
    <td><pre><code>&lt;div class="b1 i-bem"
    data-bem="{ 'b1': {} }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
<tr>
    <td><pre><code>{block: 'b1'}</code></pre></td>
    <td><pre><code>block('b1').js()({param: 'value'})</code></pre></td>
    <td><pre><code>&lt;div class="b1 i-bem"
    data-bem="{ 'b1': { 'param': 'value' } }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
</table>

**См. также**:

  * [JS-реализация блока i-bem](http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html)

<a name="bem"></a>

#### bem

* *Тип значения тела шаблона: `Boolean`*
* *Значение по умолчанию: `true`*

Мода `bem` указывает, нужно ли при формировании HTML-атрибута `class` включать автоматически сгенерированные имена
классов, описывающие данную БЭМ-сущность. По умолчанию генерация БЭМ-классов выполняется. Фрагмент HTML, за генерацию
которого отвечает мода `bem`, выделен на рисунке:

![mode-bem](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_bem.png)

Определение шаблона по моде `bem` (подпредикат `bem()`) имеет смысл только в том случае, если для данной сущности
**не нужно** генерировать HTML-классы, относящиеся к БЭМ-предметной области. Это может быть необходимо для соблюдения
синтаксических требований HTML. Например, теги `html`, `meta`, `link`, `script`, `style` не могут иметь атрибута `class`.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b-page'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b-page')(
  tag()('html'),
  bem()(false)
)</code></pre>
    </td>
    <td><pre><code>&lt;html&gt;&lt;/html&gt;</code></pre></td>
</tr>
</table>

<a name="cls"></a>

#### cls

* *Тип значения тела шаблона: `String`*
* *Значение по умолчанию: `''`*

Мода `cls` позволяет определить произвольную строку, добавляемую в значение атрибута `class` помимо автоматически
генерируемых значений. Фрагмент HTML, за генерацию которого отвечает мода `cls`, выделен на рисунке:

![mode-cls](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_cls.png)

Определение шаблона по моде `cls` (подпредикат `cls()`) имеет смысл в том случае, если для данного элемента необходимы
специфические HTML-классы, не относящиеся к предметной области БЭМ.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td><pre><code>block('b1').cls()('custom')</code></pre></td>
    <td><pre><code>&lt;div class="b1 custom"&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>

<a name="mix"></a>

#### mix

* *Тип значения тела шаблона: `Array|Object`*
* *Значение по умолчанию: `[]`*

Мода `mix` задает список БЭМ-сущностей, которые необходимо **примешать** к данной сущности. Сущность, в рамках которой
выполняется примешивание, называется **базовой**, а добавляемая сущность — **примешиваемой**. Имеет смысл примешивание
блоков и элементов.

Технически примешивание сводится к следующим операциям:

  * БЭМ-классы примешиваемой сущности добавляются в значение атрибута `class` текущего элемента наряду с классами
    базовой сущности;
  * Если примешиваемая сущность имеет JavaScript-параметры, они добавляются в значение атрибута, заданного модой
    `jsAttr`. JavaScript-параметры передаются в виде хэша, ключом является имя примешиваемой сущности.

Все прочие составляющие HTML-элемента (тег, атрибуты и под.) генерируются на основании шаблонов для базовой сущности.

Значением тела шаблона для данной моды может быть:

  * **Массив**, в котором содержится список объектов (хэшей), каждый из которых описывает БЭМ-сущности, которые
    необходимо подмешать.
  * **Объект**, описывающий примешиваемую БЭМ-сущность. Интерпретируется как массив, состоящий из одного элемента.

Фрагмент HTML, за генерацию которого отвечает мода `mix`, выделен на рисунке:

![mode-mix](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_mix.png)

Определение шаблона по моде `mix` (подпредикат `mix()`) требуется, когда необходимо выполнить примешивание блока
или элемента на уровне шаблонизатора.

***
**NB** Примешивание БЭМ-сущностей выполняется рекурсивно. Иными словами, если для примешиваемой сущности определен
шаблон, в котором к ней примешиваются еще какие-либо сущности, все такие сущности добавляются рекурсивно и классы
для них появятся в атрибуте `class` базовой сущности (см. пример ниже).


<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1'
  js: { p: 1 }
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').mix()({
  block: 'b2',
  js: { p: 2 }
})</code></pre>
    </td>
    <td><pre><code>&lt;div class="b1 b2 i-bem"
    data-bem="{
        'b1': { 'p': 1},
        'b2': { 'p': 2}
    }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').mix()([ { block: 'b2' } ])
block('b2').mix()([ { block: 'b3' } ])
block('b3').mix()([ { block: 'b4' } ])
block('b4').mix()([ { block: 'b1' } ])</code></pre>
    </td>
    <td><pre><code>&lt;div class="b1 b2 b3 b4"&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>

***

<a name="jsAttr"></a>

####jsAttr

* *Тип значения тела шаблона: `String`*
* *Значение по умолчанию: `'data-bem'`*

Мода `jsAttr` определяет имя HTML-атрибута, в значении которого будут переданы параметры клиентского JavaScript для
данного блока. По умолчанию используется атрибут `data-bem`. Фрагмент HTML, за генерацию которого отвечает мода `jsAttr`,
выделен на рисунке:

![mode-jsattr](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_jsattr.png)

Определение шаблона по моде `jsAttr` (подпредикат `jsAttr()`) необходимо в том случае, если требуется передавать параметры JavaScript в нестандартном атрибуте. 

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>
<tr>
    <td>
        <pre><code>{
  block: 'b1',
  js: true
}</code></pre>
    </td>
    <td><pre><code>block('b1').jsAttr()('ondblclick')</code></pre></td>
    <td><pre><code>&lt;div class="b1 i-bem"
    ondblclick="{'b1': {} }"&gt;
&lt;/div&gt;</code></pre></td>
</tr>
</table>

<a name="attrs"></a>

