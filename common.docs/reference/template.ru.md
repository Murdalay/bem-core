##Шаблонизация данных в bem-core

###Общие сведения
В `bem-core` реализован механизм двухэтапной шаблонизации данных. На первом этапе нормализованные данные, получаемых от бэкенда, преобразуются к вью-ориентированному представлению.  Эту функцию выполняет шаблонизатор [BEMTREE](). 

BEMTREE формирует **БЭМ-дерево** в формате BEMJSON. БЭМ-дерево описывает:

* структуру страницы – порядок и вложенность блоков;
* названия БЭМ-сущностей – имена блоков, элементов, модификаторов блока или элемента;
* состояния БЭМ-сущностей – наличие логических модификаторов, значения модификаторов.
* произвольные поля – вспомогательные данные (хеш-ключи, адреса публичных API, и т.п.)

На втором этапе, ранее сформированный BEMJSON поэлементно преобразуется в HTML. Эту функцию выполняет шаблонизатор BEMHTML. 

Для каждой БЭМ-сущности создаются HTML-тэги, классы и атрибуты, в соответствие с  BEMHTML шаблонами для этой сущности.

**NB** При двухэтапной шаблонизации предполагается, что каждый участвующий в **сборке** блок, содержит реализацию BEMHTML- и BEMTREE-шаблонов. То же относится и к элементам.



### Синтаксис шаблонов

В данном разделе описаны все синтаксические конструкции языков BEMHTML и BEMTREE.

<a name="template"></a>

#### Шаблон

Шаблон состоит из двух выражений — **предиката** и **тела**.
Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий).

Предикат шаблона истинен тогда и только тогда, когда истинны все
подпредикаты. Порядок записи подпредикатов не имеет значения, *порядок проверки подпредикатов не гарантируется*.

Для описания шаблона используется ключевое слово `match`.  Ключевое слово `match` — это метод-хелпер, принимающий аргументом
перечень подпредикатов. Метод возвращает функцию, принимающую аргументом тело шаблона.

```js
match(подпредикат1, подпредикат2, подпредикат3)(тело);
```

Например:

```js
match(this.block === 'link', this._mode === 'tag', this.ctx.url)('a');
```

Тот же набор подпредикатов может быть записан цепочкой:

```js
match(this.block === 'link').match(this._mode === 'tag').match(this.ctx.url)('a');
```


Логически программа на BEMHTML и BEMTREE представляет собой одноранговый (плоский) **список шаблонов**. Однако если несколько
шаблонов имеют **общие подпредикаты**, они могут быть записаны в виде вложенной структуры для минимизации повторов
в коде.

Вложенные подпредикаты помещаются в тело общего подпредиката и отделяются друг от друга запятыми. Уровень
вложенности подпредикатов не ограничен.

```js
match(подпредикат1)(
  match(подпредикат2)(тело1),
  match(подпредикат3)(тело2)
)
```

Данная запись эквивалентна следующей:

```
match(подпредикат 1).match(подпредикат 2)(тело1)
match(подпредикат 1).match(подпредикат 3)(тело2)
```

***
**NB** Если для данного контекста определено более одного шаблона, то
больший приоритет имеет **последний** в порядке перечисления в файле шаблона.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.
***

**См. также**:

* [Проверка подпредикатов в определенном порядке](#check_predicate)

<a name="podpredicate"></a>

#### Подпредикаты

Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона
соответствует элементарному условию.

В BEM-XJST предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков
и элементов, имен и значений модификаторов.

Для сокращенной записи подпредикатов используются ключевые слова, относящиеся к БЭМ-предметной области. 
В частности, они избавляют от необходимости использовать ключевое слово `match` в БЭМ-ориентированных подпредикатах.


Следующие предикаты тождественны:

```js
match(this.block === 'foo').match(this.elem === 'bar')
```

```js
block('foo').elem('bar')
```

Используются следующий набор ключевых слов:

<table>
<tr>
    <th>Ключевое слово</th>
    <th>Аргументы</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>block</code></td>
    <td>имя блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code> или произвольное js-выражение</td>
    <td><pre><code>block('b-menu'), block('b' + '-menu')</code></pre></td>
</tr>
<tr>
    <td><code>elem</code></td>
    <td>имя элемента</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+</code> или произвольное js-выражение</td>
    <td><pre><code>block('b-menu').elem('item')</code></pre></td>
</tr>
<tr>
    <td><code>mod</code></td>
    <td>имя и значение модификатора блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
    <td><pre><code>block ('b-head-logo').mod('size', 'big')</code></pre></td>
</tr>
<tr>
   <td><code>mods</code></td>
   <td>имя и значение модификатора элемента</td>
   <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
   <td><pre><code>block('b-head-logo').elem('text').mods('size', 'big')</code></pre></td>
</tr>
</table>

Идентификаторы блоков, элементов, модификаторов и их значений представляют собой строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть
указано любое JS-выражение, которое будет приведено к строке. Например, запись `block('b-head-logo')` тождественна записи `block('b-' + 'head' + '-logo')`.

----
**NB** Важно не путать в предикатах модификаторы блока и модификаторы элемента.

 * `block('input').mod('theme', 'black').elem('hint')` задает элемент `hint`, вложенный в блок `input` с **модификатором блока**
   `theme` в значении `black`.
 * `block('input').elem('hint').mods('visibility', 'visible')` задает элемент `hint` с **модификатором элемента** `visibility`
   в значении `visible` вложенный в блок `input`.
 * `block('input').mod('theme', 'black').elem('hint').elemMod('visibility', 'visible')` задает элемент `hint` с **модификатором
   элемента** `visibility` в значении `visible` вложенный в блок `input` с **модификатором блока** `theme` в значении
   `black`.

Для модификаторов блоков и элементов используются разные ключевые слова, чтобы дать возможность комбинировать
в предикатах условия, одновременно включающие упоминания модификаторов блоков и элементов.

***
Чтобы шаблоны выполнялись без компиляции, было добавлено ключевое слово `elemMatch`. Оно используется при записи произвольного подпредиката для элемента:


```js
block('my-block')
    .elemMatch(function() { return this.elem === 'e1' || this.elem === 'e2'  })
        .tag()('span')
```


Дело в том, что в процессе обработки к шаблонам, где нет
подпредикатов, описывающих элементы, автоматически добавляется
подпредикат `!this.elem`. Это позволяет избежать срабатывания шаблонов
для блока на элементах этого же блока. 

Как следствие, приведенный выше пример, записанный с конструкцией `match` вместо `elemMatch`, работать не будет. Ведь в процессе обработки к нему будет добавлен подпредикат  `!this.elem`.


<a name="moda2"></a>

##### Мода

В качестве подпредиката может выступать метод-хелпер для одной из [стандартных мод](#standardmoda). Это означает, что данный
предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:
В BEMHTML:
* `default` (`def`)
* `tag`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `attrs`
* `content`

В BEMTREE:
* `default` (`def`)
* `content`

Хелпер для стандартных мод записывается в виде:

```
ключевое-слово()(тело)
```

Например:

```js
tag()('a')
```
или

```js
js()(true)
```

Для определения подпредиката по нестандартной моде
используется ключевое слово `mode`. Это метод-хелпер, действующий
аналогично конструкции `match`. Метод принимает аргументом строку-идентификатор (`[a-zA-Z0-9-]+`) — название нестандартной моды — и возвращает функцию, аргументом которой служит тело шаблона. Таким образом, запись `mode('my-mode')` эквивалентна записи `match(this._mode = 'my-mode')`.


<a name="random_condition"></a>

##### Произвольное условие

Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного
условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в <a name="xjst-canonical"></a> **канонической форме XJST**:

```
предикатное выражение === значение
```

Где

* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение.

При этом количество **различных** предикатных выражений в подпредикатах шаблонов должно быть минимизировано.
Соблюдение этих условий позволит компилятору XJST производить оптимизации над произвольными условиями шаблонов
наряду с оптимизацией стандартизованных условий (БЭМ-сущности и моды).


Для записи произвольного предикатного выражения используется ключевое слово `match`. Например:

```js
match(this.ctx.url)( //произвольное условие. Проверяет наличие поля url во входных данных
        tag()('a'), 
        attrs()({ href: this.ctx.url })
    )
```

Произвольный подпредикат `this.ctx.url` будет истинен, в случае, когда полю `url` во входных данных присвоено значение. В этом случае будет выполнено тело шаблона.
***

<a name="body"></a>

#### Тело

Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного результата:
* фрагмента HTML для BEMHTML-шаблона;
* фрагмента BEMJSON, в случае с BEMTREE.


В качестве тела шаблона может выступать:

* Отдельное JavaScript-выражение:

```js
match(предикат)(JS-выражение)
```

* Блок JavaScript-кода:

```js
match(предикат)(function() { JS-код })
```

* Литерал объекта (хеш):

```
match(предикат)({name: value})
```


***
**NB** Необходимость оборачивать блок  JavaScript-кода в безымянную функцию продиктована особенностями исполнения шаблонов в среде разработки. Это рекомендуемый способ. Он позволяет избежать возникновения ошибки при обращении к полям контекста, которые могут быть еще не определены на момент выполнения шаблона.

В случае, если блок JavaScript-кода представляет из себя простой константный литерал, необходимость в безымянной функции отсутствует.
***


Тело шаблона передается аргументом в функцию, возвращаемую методом `match` и хелперами для БЭМ-сущности или моды.


Синтаксис:

```
стандартная-мода()(тело)

mode('нестандартная-мода')(тело)

БЭМ-сущность('имя-сущности')(тело)

match(произвольный предикат)(тело)
```


***
**NB**  Важно помнить, что тело шаблона передается в функцию, возвращаемую методом-хелпером, а не в сам хелпер. 


Неправильно:
```js
block('b1').tag('span') 
```

Правильно:

```js
block('b1').tag()('span')
```

***

В рамках тела шаблона можно выполнить следующие действия:

* Вычислить и вернуть значение.
  Если в текущей моде ожидается значение определенного типа, значение, возращаемое при вычислении тела шаблона, будет
  приведено к этому типу и использовано. Если шаблон не возвращает никакого значения, будет использовано значение
  `undefined`.
* Вывести данные непосредственно в HTML-результат (BEMJSON).
  Для этого в теле шаблона следует выполнить запись в буфер результата (`this._buf.push(…)`).
* Производить произвольные операции.

<a id="xjst"></a>

#### Специальные конструкции BEM-XJST

Для интерпретации BEMHTML-шаблонов используется модуль [bem-xjst](https://github.com/bem/bem-xjst). BEM-XJST  представляет собой набор БЭМ-ориентированных хелперов, расширяющих предметную область языка [XJST](https://github.com/veged/xjst).

Помимо хелперов для БЭМ-сущностей и названий мод в BEMHTML-шаблонах возможно использовать специальные синтаксические
конструкции BEM-XJST. Они предназначены для модификации контекста и явного вызова процедуры выбора и выполнения шаблонов в измененном контексте.


***
**NB** Обратите внимание, что функциональность и синтаксис BEM-XJST-конструкций (например, конструкции`apply()`) может отличаться от синтаксиса и функциональности аналогичных конструкций языка XJST.
***


<a id="local"></a>

##### local

Конструкция `local` используется для временного изменения контекста и переменных, а также для последующих
операций с ними. По синтаксису блок кода `local` подобен блокам `while` и `for` в JavaScript.

Блок `local` записывается в виде:

```
local(this)({hash})(function() {
    // code
})
```


Здесь

* `this` — объект, используемый в качестве контекста. Может не указываться, тогда будет использован текущий контекст;
* `hash` — хеш, ключи которого – это поля контекста. В хеше могут использоваться вложенные конструкции вида `ctx.foo`. Переданные в хеше значения переменных будут присвоены полям контекста в момент выполнения блока `local`;
* `code` — JavaScript-код, который выполняется в контексте, где значения переменных соответствуют присвоенным в блоке
  `hash`.

По выходу из блока local все переменные, значения которых изменялись в блоке `hash`, приобретают те значения, которые в них хранились на момент входа в блок. 

***
**NB** Если в блоке `hash` было присвоено значение переменной (полю объекта), которая не была определена на момент входа в блок `local`, по выходу из блока `local` эта переменная (поле) будет существовать и получит значение `undefined`.

***

Блок `hash` может записываться следующим образом:

```js
local()({ x: 1, 'a.b.c': 2 })(function() {

   // statements body

})
```


<a id="apply"></a>

##### apply

Конструкция `apply` предназначена для явного вызова процедуры выбора и выполнения шаблона, предикат которого истинен
в данном контексте. Конструкция позволяет вызывать шаблоны в модифицированном контексте.

Синтаксис:

```js
apply(expressions)
```

Где `expressions` — это список выражений, модифицирующих контекст.  Список может быть пуст.

Каждое выражение в списке `expressions` может представлять собой:

* Хеш значений переменных, используемых для модификации контекста. Аналогичен блоку hash в [конструкции local](#local).
* Строку или приводимое к ней выражение. Означает «выставить указанную строку в качестве моды».

    Например, выражение `apply('content')` эквивалентно выражению`apply(this._mode = 'content')`.

При вычислении выражения `apply` выполняются следующие шаги:

1. Выполнение выражений (присваиваний) в блоке `expressions`.
2. Вызов процедуры выбора и выполнения шаблона в контексте, полученном в результате шага 1.
3. Восстановление значений переменных.

Конструкция `apply(expressions)` представляет собой сокращенную запись выражения `local(expressions)(apply())`.

<a id="applynext"></a>

##### applyNext

Конструкция `applyNext` позволяет заново запустить процедуру применения шаблонов к текущему контексту непосредственно
в теле шаблона. Результат вычисляется так, как если бы шаблона, в котором используется данная конструкция, не было.
Конструкция возвращает значение, вычисленное в результате применения шаблонов к текущему контексту.

Синтаксис:

```js
applyNext(expressions)
```

Где `expressions` — список выражений, модифицирующих контекст (операций присваивания значений переменным или строка,
означающая присвоение моды). Список может быть пуст. Аналогично блоку `expressions` в [конструкции apply](#apply).

При вызове `applyNext` выполняются следующие шаги:

  1. Создание в контексте флага, позволяющего избежать бесконечной рекурсии при вызове шаблонов. В качестве флага
     используется случайное число.
  2. Добавление в предикат шаблона проверки на наличие флага.
  3. Выполнение блока `expressions` (модификация текущего контекста).
  4. Вызов процедуры выбора и выполнения шаблона `apply()`.
  5. Возвращение значения, полученного в результате выполнения шаблона.

Например, шаблон

```js
block('b1')(
    statements
    applyNext()
)
```

эквивалентен следующему шаблону:

```js
var _randomflag = ~~(Math.random() * 1e9)
block('b1').match(!this.ctx[_randomflag])(
    statements
    local(this.ctx[_randomflag] = true) apply()
)
```

Где `statements` — произвольные JS-выражения, допустимые в теле шаблона.

**См. также**:

* [Наследование](#inheritage)
* [Добавление БЭМ-сущностей для задач верстки](#additionbem)


<a id="applyctx"></a>

##### applyCtx

Конструкция `applyCtx` предназначена для модификации фрагмента входного БЭМ-дерева `this.ctx` и последующего вызова
процедуры применения шаблонов `apply()` к контексту с модифицированным БЭМ-деревом.

Синтаксис:

```js
applyCtx(newctx)
```

Где в качестве `newctx` может выступать:

* Объект (хэш), который будет использован в качестве входного фрагмента БЭМ-дерева. Может содержать ссылки на исходный `this.ctx`.
* Операция присваивания переменной.

В ходе вычисления выражения `applyCtx` выполняются следующие шаги:

  1. Выставление [пустой моды](#pustajamodaquotquot) в качестве текущей.
  2. Вызов процедуры выбора и выполнения шаблона `apply()`.
  3. Возвращение значения, полученного в результате выполнения шаблона.

Выражение `applyCtx(newctx)` представляет собой сокращенную запись для выражения `applyNext(this.ctx = {newctx}, '')`.


***
**NB** При использовании объекта this.ctx в качестве аргумента для applyCtx() нужно:

* добавить в контекст флаг, позволяющий избежать бесконечной рекурсии при вызове шаблона;
* добавить в предикат шаблона проверку на наличие флага.

***



**См. также**:

  * [Оборачивание блока в другой блок](#wrappingunit)
  * [Добавление БЭМ-сущностей для задач верстки](#additionbem)

