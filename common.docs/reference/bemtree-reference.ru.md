<a id="intro"></a>

### Введение

**Данный документ** представляет собой справочное руководство по шаблонизатору BEMTREE.

В документе описаны:

* основные особенности BEMTREE, отличающие его от других шаблонизаторов;
* порядок обработки входных данных и генерации BEMJSON;
* примеры решения типовых задач средствами BEMTREE.

**Целевая аудитория документа** — веб-разработчики и HTML-верстальщики, использующие
[БЭМ-методологию](http://ru.bem.info/method/).

Предполагается, что читатель знаком с:

* HTML;
* JavaScript;
* CSS;
* BEMHTML;
* BEMJSON;
* БЭМ.



**В документе не описаны** настройка среды сборки и процедура сборки шаблонов. Процесс получения данных от бекенда.


<a name="bemtree"></a>

### Особенности шаблонизатора BEMTREE

<a id="bem_area"></a>

#### Привязка к БЭМ-предметной области

Шаблонизатор BEMTREE входит в связку технологических решений, обеспечивающих создание веб-интерфейсов в рамках
[БЭМ-методологии](http://ru.bem.info/method/).

Входные данные шаблонизатора — БЭМ-дерево в формате [BEMJSON](#bemjson), описывающее базовую структуру веб-страницы и произвольные данные, полученные от бэкенда или иным путем.
Язык шаблонов BEMTREE предлагает специальные конструкции для обработки блоков, элементов и модификаторов.

BEMTREE-шаблоны создаются в **декларативном стиле** — как набор утверждений вида *условие (БЭМ-сущность, поле контекста) — BEMJSON-представление*.


#### Язык описания шаблонов — JavaScript

BEMTREE представляет собой специализированный язык (DSL), **расширяющий** JavaScript.

Точнее, BEMTREE является надмножеством языка шаблонов [XJST](https://github.com/veged/xjst/), который, в свою очередь,
является надмножеством JavaScript.

Синтаксис BEMTREE предоставляет лаконичный способ записи соответствия БЭМ-сущностей и их BEMJSON-представления.
Помимо этого, в шаблонах могут использоваться **любые** JavaScript-конструкции.

<a id="execution_language"></a>

#### Язык исполнения шаблонов — JavaScript

Перед выполнением BEMTREE компилируется в оптимизированный JavaScript, который принимает и возвращает BEMJSON.

Такой шаблон может выполняться как на стороне сервера, так и на стороне клиента.

<a id="restrictions"></a>

#### Ограничения на уровне соглашений

Разработчики BEMTREE стремились сделать его максимально гибким инструментом, поэтому в BEMTREE не предусмотрено
технологических ограничений на операции, выполняемые в шаблонах. Фактически, в BEMTREE-коде возможно всё, что возможно
в JavaScript.

Все ограничения, обеспечивающие корректность и эффективность выполнения задач шаблонизатора, реализуются на уровне
соглашений по написанию шаблонов. Такие соглашения приводятся в данном документе в качестве рекомендаций. Разработчик
имеет техническую возможность не следовать соглашениям, но в этом случае следует взвесить преимущества и недостатки
своего решения.

<a id="basic"></a>

### Основные понятия

<a id="template"></a>
#### Кратко о шаблонзации

BEMTREE – шаблонизатор рассчитан на использование в связке с шаблонизатором BEMHTML.

BEMHTML — поэлементно преобразует входное БЭМ-дерево в выходной HTML-документ. 

Поэтому структура входного БЭМ-дерева должна быть максимально ориентирована на **представление** (view), чтобы при генерации
HTML-дерева не требовалось изменять набор и порядок блоков и элементов. 

Приведение БЭМ-дерева к такому развернутому виду и является задачей технологии BEMTREE. 


<a id="inputdata"></a>

#### Входные и результирующие данные: BEMJSON

Поскольку BEMTREE основан на JavaScript, в качестве формата представления БЭМ-дерева выбран JSON с набором
дополнительных соглашений о представлении БЭМ-сущностей — BEMJSON.

BEMJSON служит входными и выходными данными для шаблонизатора BEMTREE. При этом, входное БЭМ-дерево представляет собой каркас веб-страницы, который в процессе работы шаблонизатора поэлементно донасыщается данными.

Входной BEMJSON может состоять из описания всего одной БЭМ-сущности, с которой начинается выполнение BEMTREE-шаблонов проекта – **точки входа**.

Тогда, в BEMTREE-шаблон для БЭМ-сущности, являющейся точкой входа, включаются ссылки на другие БЭМ-сущности. В ходе выполнения шаблона точки входа, шаблонизатор рекурсивно вызывает BEMTREE-шаблоны, на которые шаблон ссылался. 

Таким образом поэлементно выстраивается БЭМ-дерево всего документа.




<a name="templatebemjson"></a>

#### Шаблон

Единицей программы на BEMTREE является **шаблон**. Шаблон BEMTREE связывает входную БЭМ-сущность (заданную именем блока, элемента, именем и значением модификатора) и соответствующий этой сущности фрагмент данных.

Шаблон состоит из:

* **предиката** — набора условий, при выполнении которых применяется шаблон. Типичный предикат описывает свойства  входной БЭМ-сущности;
* и **тела** — инструкций по генерации выходного BEMJSON.

**См. также**:

* [Синтаксис BEMHTML](#bemhtml)


<a name="context"></a>

#### Контекст

В процессе обхода входного BEMJSON-дерева шаблонизатор строит **контекст** — структуру данных, которая доступна в момент применения шаблонов. Контекст соответствует текущему элементу (узлу) входного БЭМ-дерева и включает:

* нормализованные сведения о текущей БЭМ-сущности;
* фрагмент входных данных без модификаций (текущий элемент BEMJSON-дерева и его потомки);
* строковый буфер, в который записывается BEMJSON;
* служебные поля, содержащие сведения о текущем состоянии (мода и т.п.);
* вспомогательные функции.

БЭМ-сущность, описываемая текущим контекстом, называется **контекстной сущностью**.

**См. также**:

* [Поля контекста](#context_field)



<a name="moda"></a>

#### Мода

В процессе работы шаблонизатор последовательно обходит узлы входного БЭМ-дерева. Для каждого узла — БЭМ-сущности —
выполняется цикл генерации выходного BEMJSON. Для вложенных сущностей цикл генерации BEMJSON выполняется
рекурсивно. Таким образом, выходное БЭМ-дерево формируется поэлементно в процессе обхода входного БЭМ-дерева.

Цикл генерации каждого элемента последовательно проходит ряд фаз, называемых **модами**. Каждая мода отвечает
за определенный фрагмент генерируемого BEMJSON. В каждой моде вызывается процедура
выбора и выполнения подходящего шаблона.

Моды BEMTREE полностью аналогичны модам BEMHTML, за тем исключением, что в BEMTREE отсутствуют моды, отвечающие за генерацию фрагментов HTML-элемента.

Таким образом, в BEMTREE-шаблонах помимо пустой моды, определяющей алгоритм обхода входного БЭМ-дерева и вызова остальных мод, доступны только две моды:

* мода `default`,  которая отвечает за генерацию элемента БЭМ-дерева вцелом. Обычно используется для замены контекстной сущности (например, чтобы [обернуть блок в другой блок](#wrappingunit))
* мода `content`, описывающая содержимое текущего элемента БЭМ-дерева.




<a name="syntax"></a>

#### Синтаксис шаблонов
Для обработки BEMTREE-шаблонов, используется модуль [bem-xjst](https://github.com/bem/bem-xjst).

BEM-XJST — это набор БЭМ-ориентированных хелперов, расширяющий стандартный XJST-синтаксис. Он позволяет использовать:

  * хелперы для записи подпредикатов, относящихся к предметной области БЭМ; 
  * хелперы для определения подпредиката по моде;
  * хелперы для применения XJST-конструкций `apply` и `applyNext` по произвольной моде;
  * конструкцию [applyCtx](http://ru.bem.info/libs/bem-core/1.0.0/bemhtml/reference/#applyctx).


BEM-XJST является надмножеством [языка шаблонов XJST](https://github.com/veged/xjst), который, в свою очередь, является надмножеством JavaScript.

BEM-XJST использует канонический XJST-синтаксис, расширенный набором правил, относящихся к предметной области БЭМ. 

BEMTREE-шаблоны создаются с помощью [унифицированного синтаксиса шаблонов](#unity). На практике это означает, что в BEMTREE-шаблонах могут быть использованы все те же синтаксические конструкции, которые доступны в BEMHTML-шаблонах.

Основная разница в синтаксе этих двух технологий заключается в количестве доступных стандартных мод и в полях контекста.



<a name="standardmoda"></a>

### Стандартные моды

В ядре BEMHTML определен набор стандартных мод, которые задают порядок обхода входного БЭМ-дерева (BEMJSON) и генерации выходного HTML, используемый BEMHTML по умолчанию.

По функциональности моды разделяются на два класса:

  * **«Пустая» мода** определяет алгоритм обхода узлов входного BEMJSON и вызова остальных мод;
  * Все остальные моды определяют порядок генерации выходного BEMJSON. В каждой из таких мод формируется тот или иной
    фрагмент выходного BEMJSON-дерева.

Для генерации BEMJSON в каждой моде вызывается процедура выбора и выполнения подходящего шаблона (предикат которого истинен
в данном контексте). Результат вычисления тела выбранного шаблона подставляется в тот фрагмент BEMJSON-дерева (БЭМ-сущность), за генерацию которого отвечает данная мода.

Данная логика работы накладывает следующие ограничения на шаблоны:

  * Если шаблон выводит какие-то данные в BEMJSON, в его предикате должна быть указана мода.
  * В предикате шаблона может быть указано не более одной моды.
  * В результате вычисления тела шаблона должен возвращаться тот тип объекта, который ожидается в рамках данной моды.

В последующих разделах моды перечислены в порядке их вызова при обработке элемента входного BEMJSON.

<a name="empty_moda"></a>

#### «Пустая» мода (`""`)

*Тип значения тела шаблона: `не используется`*

Пустая (не определенная) мода соответствует моменту, когда значение поля контекста `this._mode` равно пустой стоке
(`""`). Это значение выставляется:

  * перед началом обработки входного дерева;
  * в момент рекурсивного вызова процедуры обхода дерева в моде `default`.

Действие, выполняемое в рамках пустой моды, зависит от типа контекстного (текущего) элемента входного BEMJSON-дерева.

<table>
<tr>
    <th>Тип элемента</th>
    <th>Действие</th>
</tr>
<tr>
    <td><b>БЭМ-сущность</b>(блок или элемент)</td>
    <td>Выставление значений в служебных полях контекста (<code>block elem mods elemMods ctx position</code>)
    и вызов шаблонов по моде <code>default</code>.</td>
</tr>

<tr>
    <th>строка/число</th>
    <td>Вывод значения, приведенного к строке, в буфер BEMJSON-результата.</td>
</tr>
<tr>
    <th>Boolean, undefined, null</th>
    <td>Вывод пустой строки в буфер BEMJSON-результата.</td>
</tr>
<tr>
    <th>массив</th>
    <td>Итерация по массиву с рекурсивным вызовом шаблонов по пустой моде.</td>
</tr>
</table>

Определение шаблона по пустой моде (подпредикат `mode(this._mode === "")`) имеет смысл только в том случае, если необходимо
переопределить принцип обхода входного дерева.

Вызов шаблонов по пустой моде (конструкция `apply('')` в теле шаблона) необходим, если требуется отклониться
от однозначного соответствия «входная БЭМ-сущность — выходной BEMJSON-элемент» и сгенерировать более одного элемента на одну входную сущность. В частности, такой вызов осуществляется автоматически при использовании
[конструкции applyCtx](#applyctx).

**См. также**:

  * [Оборачивание блока в другой блок](#wrappingunit)

<a id="default"></a>

#### default

*Тип значения тела шаблона: `не используется`*

В рамках моды `default` полностью формируется выходной BEMJSON-элемент, соответствующий входной БЭМ-сущности.

В ходе выполнения моды `default` происходит:

  * вызов всех остальных стандартных мод, отвечающих за формирование отдельных аспектов BEMJSON-элемента;
  * объединение результатов выполнения всех вызываемых мод в результирующий BEMJSON;
  * рекурсивный вызов шаблонов на результат выполнения моды `content`.


Определение шаблона по моде `default` (подпредикат `default`) необходимо в тех случаях, когда нужно переопределить процедуру генерации выходного фрагмента BEMJSON. Например, следующий BEMTREE-шаблон доопределяет блок `page` с уровня переопределения`common-blocks`:


```js
block('page').def()(function() {

    this.ctx = {
        block: this.block,
        title: this.ctx.title,
        head: [
            { elem: 'css', url: this.ctx.css, ie: false },
            { elem: 'js', url: this.ctx.js }
        ],
        content: {
            block: 'contacts',
            index: this.ctx.index,
            content: this.ctx.contacts
        }
    };

    return applyNext();

});
```

В нем в момент вызова по моде `default` определяются поля в объекте входных данных `this.ctx`. Затем, с помощью конструкции `applyNext` производится вызов базовой реализации шаблона `page` (с уровня `common-blocks`), с модифицированным `this.ctx`.


<a name="content"></a>

#### content

* *Тип значения тела шаблона: `BEMJSON`*
* *Значение по умолчанию: `this.ctx.content`*

В рамках моды `content` вычисляется содержимое BEMJSON-элемента, в качестве которого может выступать произвольный BEMJSON
(как строка или число, так и дерево БЭМ-сущностей). В качестве значения по умолчанию используется значение поля
`content` контекстной БЭМ-сущности (`this.ctx.content`).


Определение шаблона по моде `content` (подпредикат `content()`) необходимо, если:

  * Необходимо на уровне шаблонизатора добавить содержимое для сущности, у которой отсутствует `content` во входном BEMJSON.
  * Необходимо подменить содержимое сущности на уровне шаблонизатора.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>результирующий BEMJSON</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').content()({
  block: 'b2'
})</code></pre>
    </td>
    <td>{ block: 'b1', content: { block: 'b2' } }
</td>
</tr>
</table>


**См. также**:

* [Наследование](#inheritage)
* [Добавление БЭМ-сущностей для задач верстки](#additionbem)

<a name="context_field"></a>

### Поля контекста

В процессе работы шаблонизатор BEMTREE строит структуру данных, содержащую сведения об обрабатываемом узле BEMJSON
и о состоянии процесса обработки. Помимо этого в контексте доступен ряд вспомогательных функций BEMTREE.

В момент выполнения шаблона контекст доступен в виде объекта, обозначаемого ключевым словом `this`. Обращение
к контексту возможно как в предикате, так и в теле шаблона.

Автор шаблонов имеет возможность определить любые дополнительные поля в контексте.

Все поля контекста можно разделить на две категории:

  * **Контекстно-зависимые**, значение которых изменяется в зависимости от обрабатываемого узла и фазы процесса обработки.
  * **Контекстно-независимые**, значение которых постоянно.

**См. также**:

  * [Контекст](#context)

<a name="contextdependent"></a>

#### Контекстно-зависимые поля

<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this.block</code></td>
    <td><code>String</code></td>
    <td>Имя блока (контекстной БЭМ-сущности).</td>
</tr>
<tr>
    <td><code>this.elem</code></td>
    <td><code>String</code></td>
    <td>Имя элемента (контекстной БЭМ-сущности).</td>
</tr>
<tr>
    <td><code>this.mods</code></td>
    <td><code>Object</code></td>
    <td>Модификаторы блока (контекстной БЭМ-сущности), <code>имя_модификатора: значение_модификатора</code>.</td>
</tr>
<tr>
    <td><code>this.elemMods</code></td>
    <td><code>Object</code></td>
    <td>Модификаторы элемента (контекстной БЭМ-сущности), <code>имя_модификатора: значение_модификатора</code>.</td>
</tr>
<tr>
    <td><code>this.ctx</code></td>
    <td><code>BEMJSON</code></td>
    <td>Фрагмент входного BEMJSON-дерева, содержащий обрабатываемый узел и его потомков в неизмененном виде.
    Используется для получения доступа к произвольным полям данных входного BEMJSON.</td>

<tr>
    <td><code>this._mode</code></td>
    <td><code>String</code></td>
    <td>Текущая мода. Если необходимо определить собственные (нестандартные) моды, в соответствующем шаблоне следует
    присваивать этому полю имя моды в момент входа в нее. </td>
</tr>
<tr>
    <td><code>this._buf</code></td>
    <td><code>Array</code></td>
    <td>Буфер BEMJSON-результата. Обычно используется только для записи готовых BEMJSON-фрагментов с использованием метода
    <code>this._buf.push()</code>.</td>
</tr>
<tr>
    <td><code>this.generateId()</code></td>
    <td><code>Number</code></td>
    <td>Возвращает уникальный идентификатор для текущего контекста. Используется, для генерации уникальных идентификаторов для  HTML-элементов, связанных с помощью атрибута <code>id</code>.</td>
</tr>
</table>

***
**NB**
Ключевые слова для проверки БЭМ-сущностей в предикате являются сокращенной записью для проверки значений полей
`block`, `elem` и т.д. в текущем контексте. Например, подпредикат `block('b1')` эквивалентен подпредикату
`match(this.block === 'b1')`.

Аналогично, ключевые слова для проверки моды в предикате являются сокращенной записью для проверки значения
служебного поля `_mode` в текущем контексте. Например, подпредикат `def()` эквивалентен подпредикату
`match(this._mode === 'default')`.
***



<a name="context_independent"></a>

#### Контекстно-независимые поля

Все контекстно-независимые поля сгруппированы в объекте `this._` и представляют собой вспомогательные функции,
используемые при работе шаблонизатора. Автор шаблонов также может пользоваться этими функциями как в теле шаблонов,
так и в предикатах.

<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this._.isArray(Object)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данный объект массивом.</td>
</tr>
<tr>
    <td><code>this._.isSimple(Object)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данный объект примитивным JavaScript типом.</td>
</tr>
<tr>
    <td><code>this._.extend(Object, Object)</code></td>
    <td><code>Object</code></td>
    <td>Возвращает хэш, объединяющий содержимое двух хэшей, переданных в качестве аргументов. Если хэши содержат
    совпадающие ключи, в результат записывается значение из хэша, переданного в качестве второго аргумента.</td>
</tr>
<tr>
    <td><code>this._.xmlEscape(String)</code></td>
    <td><code>String</code></td>
    <td>Возвращает переданную строку с заэкранированными управляющими символами XML <code>[&<>]</code>.</td>
</tr>
<tr>
    <td><code>this._.attrEscape(String)</code></td>
    <td><code>String</code></td>
    <td>Экранирует значение управляющих символов для значений XML- и HTML-атрибутов  (<code>"[&<>]</code>).</td>
</tr>
<tr>
    <td><code>this._.doAsync(Function)</code></td>
    <td><code>String</code></td>
    <td>Асинхронно выполняет функцию, переданную в качестве аргумента. Обычно используется для отправки асинхронных запросов к бэкенду. Вместе с фрагментом данных, методом сохраняется информация о контекстной БЭМ-сущности.</td>
</tr>
</table>


<a name="data"></a>

####Схемы работы с данными

Технология BEMTREE не привязана к конкретной архитектуре взаимодействия с бэкендом. 

На практике, в BEMTREE-проектах обычно используются следующие подходы к работе с поставщиками данных:
* централизованный;
* работа на уровне BEMTREE-шаблонов блока.

Каждый из подходов обладает рядом особенностей, которые стоит учитывать при выборе схемы работы с бэкендом. 


#####Централизованное получение данных

При таком подходе, взаимодействие с бэкендом осуществляет отдельный модуль – **контролер**. 

Контролер по запросу от браузера (или другому событию) отправляет запрос к бэкенду и сохраняет полученный ответ. Сохранение может производиться в глобальную переменную, в свойство глобального объекта или иным образом. 

BEMTREE-шаблон блока устанавливает соответствие между полями глобального объекта или переменной, и БЭМ-сущностями в результирующем BEMJSON.

Таким образом, шаблон не содержит никаки сведений о том, каким образом были получены данные. Равно как и контролер не заботится об их дальнейшем представлении.

При таком подходе наиболее четко реализуется принцип отделения контролера от представления данных. Это удобно для случаев, когда:
* структура и содержимое страницы известны на момент ее формирования;
* блоки не должны зависеть от схемы получения данных (например для использования во внешних проектах, библиотеках и т.д.)
* данные поставляются небольшим постоянным числом источников. Например одной СУБД. 

**NB** Обратите внимание, что при централизованном подходе к работе с данными объект данных, полученных от бэкенда, должен быть полностью сформирован на момент выполнения BEMTREE-шаблона.


#####Получение данных внутри BEMTREE-шаблона блока

Использование такой схемы оправдано в случае, если блок получает данные от источника, которым пользуется только он сам. Тогда теряется смысл в отделении контролера, т.к. его функциональность не востребована в других блоках. 
Примером могут послужить разнообразные виджеты: прогноз погоды, счетчики, свежие посты в блоге, курсы валют и т.д.

Преимущества:

* высокая автономность блоков – есть логика как для получения, так и для представления данных;
* возможность использования нескольких независимых источников данных;
* можно использовать совместно с централизованной схемой получения данных;
* 


К недостаткам такого подхода можно отнести:

* смешение функциональности контролера данных с функциональностью вью-ориентированного шаблонизатора;
* ограниченная доступности данных из других блоков;
* возможные повторы кода;
* более "дорогая" поддержка кода, за счет децентрализации. Например при изменении API бэкенда.



<a name="examples"></a>

### Примеры и рецепты

<a name="bringing_input"></a>

#### Приведение входных данных к формату, ориентированному на представление

##### Задача

Сформировать входное БЭМ-дерево для страницы френдленты (список постов с указанием информации об авторе), удобное
для обработки в терминах шаблонов BEMHTML. Такое дерево должно быть ориентировано на представление, т.е. набор
и порядок БЭМ-сущностей должен соответствовать набору и порядку DOM-узлов выходного HTML.

##### Решение

Бэкенд обычно работает с нормализованными данными (data-ориентированный формат). В случае френдленты
формат исходных данных может быть таким:

```js
{
    posts: [ { text: 'post text', author: 'login' }, … ],
    users: [ { 'login': { userpic: 'URL', name: 'Full Name' } }, … ],
}
```

Данные представлены как два списка объектов разных типов. В списке постов используется только идентификатор
пользователя, а полная информация о пользователе находится в соответствующем хеше в списке пользователей.

Формат данных, ориентированный на представление, предполагает денормализацию данных, т.е. развертывание списка постов
таким образом, чтобы в каждом посте содержалась полная информация об авторе, даже если в списке присутствует несколько
постов одного автора. В BEMJSON подобный формат может выглядеть так:

```js
{
    block: 'posts',
    content: [
        {
            block: 'post',
            content: [
                { block: 'userpic', content: 'URL' },
                { block: 'user', content: 'Full Name' },
                { elem: 'text', content: 'post text' }
            ]
        },
        …
    ]
}
```


<a name="inheritage"></a>

#### Наследование

##### Задача

На разных [уровнях переопределения](http://bem.github.com/bem-method/pages/beginning/beginning.ru.html#Urovnipereopredeleniy)
определены два различных шаблона на одну и ту же БЭМ-сущность (`block b1`). Каждый из шаблонов определяет своё
содержимое по моде `content`.

Необходимо на втором уровне переопределения **унаследовать** содержимое, определённое на первом уровне, и добавить
дополнительное. Требуется аналог `<xsl:apply-imports/>`.

##### Решение
В BEMTREE есть аналог `<xsl:apply-imports/>`. Реализация основывается на возможности заново запустить в шаблоне
процедуру применения шаблонов к текущему контексту (`apply()`). Таким образом можно вызвать тот шаблон, который был
определен для данного контекста (БЭМ-сущности, моды и т.п.) ранее или на другом уровне переопределения.

При вычислении выражения `apply()` возвращается результат, полученный в ходе применения ранее определенного шаблона.
Для избежания бесконечного цикла необходимо добавить подпредикат проверки наличия в контексте какого-то флага (например,
`_myGuard`), который будет выставлен при выполнении `apply()`.

```js
// шаблон на первом уровне переопределения
block('b1').content()('text1')

// шаблон на втором уровне переопределения
block('b1').match(!this._myGuard).content()([
    apply({_myGuard:true}),  // получаем предыдущее значение content
    'text2'
])
```

В результате применения шаблонов к блоку `b1` будет получен BEMJSON:

```js
{ block: 'b1', content: 'text1text2' }
```

В качестве альтернативного решения можно использовать конструкцию `applyNext`, которая автоматически генерирует уникальное имя флага против
зацикливания.

```js
block('b1').content()('text1')

block('b1').content()([
    applyNext(), // получаем предыдущее значение content
    'text2'
])
```

**См. также**:

  * [Конструкция applyNext](#applynext)


<a name="parentblock"></a>

#### Выбор шаблона в зависимости от родительского элемента

##### Задача

Для реализации языка разметки, аналогичного DocBook, нужны разные шаблоны для блока `para` в зависимости от контекста, в котором встречается данный блок. В частности, если блок `para` вложен в блок `listitem`, для него не нужно генерировать тег `<p>`.

##### Решение

В BEMTREE (а точнее, в XJST) нет неявного сохранения контекста для использования в предикатах — это сделано из соображений производительности. 

Чтобы реализовать в BEMTREE контекстную зависимость, необходимо явным образом сохранить информацию о контексте, которая потребуется при обработке вложенных блоков. 

Сохранение информации о контексте нужно реализовать в шаблоне для блока `listitem`. Используем флаг `inListItem`:

```js
block('listitem').match(!this.inListItem)(apply({inListItem:true}))
```

Обратите внимание, на подпредикат `!this.inListItem`, позволяющий избежать зацикливания при рекурсивном вызове процедуры применения шаблонов в модифицированном контексте (`apply({inListItem:true})`).

Для обработки `para`, вложенного в `listitem`, достаточно проверить наличие в контексте флага `inListItem`. 

```js
block('para').match(this.inListItem)
```


<a name="wrappingunit"></a>

#### Оборачивание блока в другой блок

##### Задача

Необходимо вложить блок (`b-inner`) в другой блок (`b-wrapper`) при выполнении шаблона. Таким образом, одному входному блоку будет соответствовать два вложенных друг в друга блока.

##### Решение

При обработке блока `b-inner` в шаблоне по моде `default` (генерация целого элемента) следует модифицировать фрагмент входного дерева `this.ctx` (добавить блок `b-wrapper`).  Для этого используется конструкция `applyCtx()`, которая присваивает `this.ctx` и применяет шаблоны по пустой моде.



```js
block('b-inner').def()
    .match(!this.ctx._wrapped)(function() {
        var ctx = this.ctx;
        ctx._wrapped=true;
        applyCtx({ block: 'b-wrapper', content: ctx })
   })


```

Для избежания бесконечного цикла необходимо при вызове выражения `applyCtx()` проверять наличие в контексте специального флага (`_wrap`), который будет выставлен при выполнении `applyCtx()`.


***
**NB** Конструкцию `applyCtx()` можно применять для **замены** БЭМ-сущности в исходном дереве, если не использовать
исходное содержимое блока (`this.ctx`) в аргументе `applyCtx()`.
***

**См. также**:

  * [Конструкция applyCtx](#applyctx)

<a name="additionbem"></a>

#### Добавление БЭМ-сущностей для задач вёрстки

##### Задача

Необходимо сверстать блок с закруглёнными уголками, работающий во всех браузерах (без использования CSS3).

Входной BEMJSON может быть таким:

```js
{ block: 'box', content: 'text' }
```

Реализация уголков требует добавления к блоку четырех дополнительных элементов. Поскольку данные элементы отражают
детали HTML-верстки, ими не следует загромождать входное БЭМ-дерево. Добавить эти элементы следует на уровне
BEMTREE-шаблона. Финальное БЭМ-дерево должно выглядеть так:

```js
{
    block: 'box',
    content: {
        elem: 'left-top',
        content: {
            elem: 'right-top',
            content: {
                elem: 'right-bottom',
                content: {
                    elem: 'left-bottom',
                    content: 'text'
                }
            }
        }
    }
}
```


##### Решение

Для модификации входного БЭМ-дерева на уровне BEMTREE потребуется написать шаблон по моде `content` для блока `box`.
Подмена фрагмента входного БЭМ-дерева (добавление необходимых элементов) выполняется с помощью конструкции `applyCtx()`,
а подстановка исходного содержимого — с помощью конструкции `applyNext()`.

BEMTREE-шаблон, выполняющий это преобразование:

```js
block('box').match(!this.ctx._processed).content()(local({'ctx._processed':true})(applyCtx({
    elem: 'left-top',
    content: {
        elem: 'right-top',
        content: {
            elem: 'right-bottom',
            content: {
                elem: 'left-bottom',
                content: applyNext()
            }
        }
    }
})))
```

**NB:** Конструкция языка XJST `local` используется в примере для вызова тела шаблона в модифицированном контексте. А именно, с флагом `ctx._processed` в значении `true`.


**См. также**:

  * [Конструкция apply](#apply)
  * [Конструкция applyNext](#applynext)
  * [Конструкция applyCtx](#applyctx)
  * [Конструкция local](#local)


<a name="check_predicate"></a>

#### Проверка подпредикатов в определенном порядке

##### Задача

Необходимо проверять подпредикаты шаблона в строго определенном порядке, например, сначала проверить наличие в контексте
объекта `this.world`, а затем проверить значение поля в этом объекте `this.world.answer`.

##### Решение

Воспользуемся тем, что подпредикат шаблона BEMTREE может быть произвольным JavaScript-выражением и запишем его
в следующей форме:

```js
match(this.world && this.world.answer === 42)
```

Недостаток этого решения в том, что при компиляции это выражение не будет оптимизировано, что отрицательно скажется на скорости работы шаблона. В большинстве случаев можно и нужно избегать необходимости в строгом порядке проверки подпредикатов.

<a name="binding_html"></a>

#### Связывание HTML-элементов по id

##### Задача

Необходимо для входного блока `input` сгенерировать пару HTML-элементов `<label>` и `<input>`, так чтобы значение
атрибута `input@id` было сгенерировано автоматически, уникально и совпадало со значением атрибута `label@for`.

Входные данные могут выглядеть так:

```js
{
  block: 'input',
  label: 'My Input',
  content: 'my value'
}
```

##### Решение

Для генерации уникального идентификатора, подходящего в качестве значения атрибута `id`, воспользуемся вспомогательной
функцией контекста `this.generateId()`. Чтобы сгенерировать два HTML-элемента на основании одного входного блока, потребуется шаблон по моде `content`, в котором будут сформированы два необходимых элемента и их атрибуты.

```js
block('input')(
  content()([
    {
      tag: 'label',
      attrs: { 'for': this.generateId() },
      content: this.ctx.label
    },
    {
      tag: 'input',
      attrs: {
        id: this.generateId(),
        value: this.ctx.content
      }
    }
  ]
))
```

