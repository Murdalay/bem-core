#### attrs

* *Тип значения тела шаблона: `Object`*
* *Значение по умолчанию: `{}`*

Мода `attrs` позволяет задать имена и значения произвольных HTML-атрибутов для данного элемента. По умолчанию
дополнительные атрибуты не генерируются. Фрагмент HTML, за генерацию которого отвечает мода `attrs`, выделен на рисунке:

![mode-attrs](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_attrs.png)

Значением тела шаблона для данной моды должен быть объект (хеш), содержащий имена и значения атрибутов в качестве
пар ключ—значение. В качестве ключа должен выступать валидный идентификатор HTML-атрибута, а в качестве значения — строка или число. При выводе HTML специальные символы в значениях атрибутов экранируются вспомогательной функцией `this._.attrEscape()`.

***
**NB** Если в качестве значения атрибута указать `undefined`, этот атрибут не будет выведен в HTML-элементе.
***

Определение шаблона по моде `attrs` (подпредикат `attrs()`) необходимо во всех случаях, когда требуется:

  * добавить произвольные HTML-атрибуты на уровне шаблонизатора;
  * исключить указанные атрибуты из вывода, даже если они были определены во входном BEMJSON.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'logo',
}</code></pre>
    </td>
    <td>
        <pre><code>block('logo')(
  tag()('img'),
  attrs()({ alt: 'logo', href: 'http://...' })
)</code></pre>
    </td>
    <td><pre><code>&lt;img alt="logo"
    href="http://..." /&gt;</code></pre></td>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'input',
  disabled: true
}</code></pre>
    </td>
    <td>
        <pre><code>block('input')(
  tag()('input'),
  attrs()({
    disabled: this.ctx.disabled ? 'disabled' : undefined
  })
)</code></pre>
    </td>
    <td><pre><code>&lt;input class="input"
    disabled="disabled"/&gt;</code></pre></td>
</tr>

<tr>
    <td>
        <code>{ block: 'input' }</code>
    </td>

    <td>Тот же шаблон</td>
    <td><pre><code>&lt;input class="input"/&gt;</code></pre></td>
</tr>
</table>

<a name="content"></a>

#### content

* *Тип значения тела шаблона: `BEMJSON`*
* *Значение по умолчанию: `this.ctx.content`*

В рамках моды `content` вычисляется содержимое HTML-элемента, в качестве которого может выступать произвольный BEMJSON
(как строка или число, так и дерево БЭМ-сущностей). В качестве значения по умолчанию используется значение поля
`content` контекстной БЭМ-сущности (`this.ctx.content`).

Фрагмент HTML, за генерацию которого отвечает мода `content`, выделен на рисунке:

![mode-content](https://raw.github.com/bem/bem-core/v1/common.docs/reference/reference_mode_content.png)

Определение шаблона по моде `content` (подпредикат `content()`) необходимо, если:

  * Необходимо на уровне шаблонизатора добавить содержимое для сущности, у которой отсутствует `content` во входном
    BEMJSON.
  * Необходимо подменить содержимое сущности на уровне шаблонизатора.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>{
  block: 'b1'
}</code></pre>
    </td>
    <td>
        <pre><code>block('b1').content()({
  block: 'b2'
})</code></pre>
    </td>
    <td><pre><code>&lt;div class="b1"&gt;&lt;div class="b2"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></td>
</tr>
</table>


**См. также**:

* [Наследование](#inheritage)
* [Добавление БЭМ-сущностей для задач верстки](#additionbem)

<a name="context_field"></a>

### Поля контекста

В процессе работы шаблонизатор BEMHTML строит структуру данных, содержащую сведения об обрабатываемом узле BEMJSON
и о состоянии процесса обработки. Помимо этого в контексте доступен ряд вспомогательных функций BEMHTML.

В момент выполнения шаблона контекст доступен в виде объекта, обозначаемого ключевым словом `this`. Обращение
к контексту возможно как в предикате, так и в теле шаблона.

Автор шаблонов имеет возможность определить любые дополнительные поля в контексте.

Все поля контекста можно разделить на две категории:

  * **Контекстно-зависимые**, значение которых изменяется в зависимости от обрабатываемого узла и фазы процесса обработки.
  * **Контекстно-независимые**, значение которых постоянно.

**См. также**:

  * [Контекст](#context)

<a name="contextdependent"></a>

#### Контекстно-зависимые поля
BEMHTML расширяет набор [контекстно-зависимых полей BEM-XJST](../templating/template.ru.md#contextdependent) следующими:
<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this.position</code></td>
    <td><code>Number</code></td>
    <td>Номер позиции текущей сущности среди ее сиблингов во входном BEMJSON-дереве (начиная с 1).</td>
</tr>
<tr>
    <td><code>this._buf</code></td>
    <td><code>Array</code></td>
    <td>Буфер HTML-результата. Обычно используется только для записи готовых HTML-фрагментов с использованием метода
    <code>this._buf.push()</code>.</td>
</tr>
<tr>
    <td><code>this.isFirst()</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данная БЭМ-сущность первой среди сиблингов во входном БЭМ-дереве..</td>
</tr>

<tr>
    <td><code>this.isLast()</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данная БЭМ-сущность последней среди сиблингов во входном БЭМ-дереве. Подробнее
    см. <a href="#algorithmbem">Алгоритм вычисления позиции БЭМ-сущности</a>.</td>
</tr>
</table>




<a name="algorithmbem"></a>

##### Алгоритм вычисления позиции БЭМ-сущности

Позиция в БЭМ-дереве (поле контекста `this.position`) представляет собой натуральное число, соответствующее порядковому
номеру текущей (контекстной) БЭМ-сущности среди ее сиблингов в БЭМ-дереве (одноранговых сущностей).

При вычислении позиции:

  * Нумеруются только те узлы обрабатываемого BEMJSON, которые соответствуют БЭМ-сущностям, прочим узлам
    не соответствует никакой номер позиции.
  * Позиции нумеруются начиная с 1.
  * Нумерация производится в порядке обхода дерева (уплощенный список иерархического представления BEMJSON).

Пример нумерации позиций во входном БЭМ-дереве:

```js
{
  block: 'page',          // this.position === 1
  content: [
    { block: 'head' },    // this.position === 1
    'text',               // this.position === undefined
    {
      block: 'menu',      // this.position === 2
      content: [
        { elem: 'item' }, // this.position === 1
        { elem: 'item' }, // this.position === 2
        { elem: 'item' }  // this.position === 3
      ]
    }
  ]
}
```

***
**NB** БЭМ-дерево может быть достроено в процессе выполнения шаблонов с помощью шаблонов по моде `content` и шаблонов
по пустой моде. Такое динамическое изменение БЭМ-дерева учитывается при вычислении позиции.
***

Функция определения последней БЭМ-сущности среди сиблингов `this.isLast()` **не сработает** в том случае, если
в массиве, содержащем одноранговые БЭМ-сущности, последний элемент не является БЭМ-сущностью. Например:

```js
  block('b1')(
    content()([
        { block: 'b2' },
        { block: 'b3' }, // this.isLast() === false
        'text'
    ])
  )
```

Такое поведение объясняется тем, что в целях оптимизации BEMHTML не выполняет предварительного полного обхода
БЭМ-дерева. Поэтому в момент обработки блока `b3` уже известна длина массива (`b3` не является последним элементом),
но еще не известно, что последний элемент не является БЭМ-сущностью и не получит номера позиции.

На практике описанный случай некорректного срабатывания `this.isLast()` не должен порождать ошибок, так как проверка
на первую/последнюю БЭМ-сущность обычно применяется к автоматически сгенерированным спискам сущностей, в которые
не имеет смысла включать данные других типов.

<a name="context_independent"></a>

#### Контекстно-независимые поля

Все контекстно-независимые поля сгруппированы в объекте `this._` и представляют собой вспомогательные функции,
используемые при работе шаблонизатора. Автор шаблонов также может пользоваться этими функциями как в теле шаблонов, так и в предикатах.

BEMHTML расширяет набор [контекстно-независимых полей BEM-XJST](../templating/template.ru.md#context_independent) следующими:


<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this._.isShortTag(String)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, принадлежит ли указанное имя тега к списку коротких тегов (не требующих закрывающего элемента  и рекурсивной обработки). Полный список коротких тегов:<code>area</code>, <code>base</code>, <code>br</code>, <code>col</code>, <code>command</code>, <code>embed</code>, <code>hr</code>, <code>img</code>, <code>input</code>,
    <code>keygen</code>, <code>link</code>, <code>meta</code>, <code>param</code>, <code>source</code>, <code>wbr</code>.</td>
</tr>
</table>

<a name="examples"></a>

### Примеры и рецепты


<a name="select_template"></a>

#### Выбор шаблона по условию

##### Задача

Блок `b-link` встречается в двух разновидностях:

  * `{ block: 'b-link', content: 'ссылка без URL' }`
  * `{ block: 'b-link', url: '//ya.ru', content: 'ссылка с URL' }`

Необходимо по-разному оформить выходной HTML-элемент в зависимости от наличия/отсутствия поля `url` в данных блока.

##### Решение
Следует сделать проверку на наличие поля `url` подпредикатом шаблона: выражение `this.ctx.url` будет истинным, только
если поле `url` определено.

```js
block('b-link')(
  tag()('span'),
  match(this.ctx.url)(
    tag()('a'),
    attrs()({ href: this.ctx.url })
  )
)
```

**Неправильно** использовать для решения этой задачи условные конструкции JavaScript в теле шаблона:

```js
block('b-link').tag()(this.ctx.url ? 'a' : 'span')
```

При компиляции это выражение не будет оптимизировано, что отрицательно скажется на скорости работы шаблона.

**См. также**:

  * [Синтаксис шаблонов](../templating/template.ru.md#template)

<a name="inheritage"></a>

#### Наследование

##### Задача

На разных [уровнях переопределения](http://bem.github.com/bem-method/pages/beginning/beginning.ru.html#Urovnipereopredeleniy)
определены два различных шаблона на одну и ту же БЭМ-сущность (`block b1`). Каждый из шаблонов определяет своё
содержимое по моде `content`.

Необходимо на втором уровне переопределения **унаследовать** содержимое, определённое на первом уровне, и добавить
дополнительное. Требуется аналог `<xsl:apply-imports/>`.

##### Решение
В BEMHTML есть аналог `<xsl:apply-imports/>`. Реализация основывается на возможности заново запустить в шаблоне
процедуру применения шаблонов к текущему контексту (`apply()`). Таким образом можно вызвать тот шаблон, который был
определен для данного контекста (БЭМ-сущности, моды и т.п.) ранее или на другом уровне переопределения.

При вычислении выражения `apply()` возвращается результат, полученный в ходе применения ранее определенного шаблона.
Для избежания бесконечного цикла необходимо добавить подпредикат проверки наличия в контексте какого-то флага (например,
`_myGuard`), который будет выставлен при выполнении `apply()`.

```js
// шаблон на первом уровне переопределения
block('b1').content()('text1')

// шаблон на втором уровне переопределения
block('b1').match(!this._myGuard).content()([
    apply({_myGuard:true}),  // получаем предыдущее значение content
    'text2'
])
```

В результате применения шаблонов к блоку `b1` будет получен HTML:

```xml
<div class="b1">text1text2</div>
```

В качестве альтернативного решения можно использовать конструкцию `applyNext`, которая автоматически генерирует уникальное имя флага против
зацикливания.

```js
block('b1').content()('text1')

block('b1').content()([
    applyNext(), // получаем предыдущее значение content
    'text2'
])
```

**См. также**:

  * [Конструкция applyNext](../templating/template.ru.md#applynext)


<a name="parentblock"></a>

#### Выбор шаблона в зависимости от родительского элемента

##### Задача

Для реализации языка разметки, аналогичного DocBook, нужны разные шаблоны для блока `para` в зависимости от контекста, в котором встречается данный блок. В частности, если блок `para` вложен в блок `listitem`, для него не нужно генерировать тег `<p>`.

##### Решение

В BEMHTML (а точнее, в XJST) нет неявного сохранения контекста для использования в предикатах — это сделано из соображений производительности. 

Чтобы реализовать в BEMHTML контекстную зависимость, необходимо явным образом сохранить информацию о контексте, которая потребуется при обработке вложенных блоков. 

Сохранение информации о контексте нужно реализовать в шаблоне для блока `listitem`. Используем флаг `inListItem`:

```js
block('listitem').match(!this.inListItem)(apply({inListItem:true}))
```

Обратите внимание, на подпредикат `!this.inListItem`, позволяющий избежать зацикливания при рекурсивном вызове процедуры применения шаблонов в модифицированном контексте (`apply({inListItem:true})`).

Для обработки `para`, вложенного в `listitem`, достаточно проверить наличие в контексте флага `inListItem`. 

```js
block('para').match(this.inListItem).tag()('')
```

Пустая строка в качестве значения шаблона по моде `tag` означает — не генерировать HTML-элемента для этого блока.


<a name="wrappingunit"></a>

#### Оборачивание блока в другой блок

##### Задача

Необходимо вложить блок (`b-inner`) в другой блок (`b-wrapper`) при выполнении шаблона. Таким образом, одному входному
блоку будет соответствовать два вложенных друг в друга блока.

##### Решение

При обработке блока `b-inner` в шаблоне по моде `default` (генерация целого элемента) следует модифицировать фрагмент
входного дерева `this.ctx` (добавить блок `b-wrapper`).  Для этого используется конструкция `applyCtx()`, которая присваивает `this.ctx` и применяет шаблоны по пустой моде.



```js
block('b-inner').def()
    .match(!this.ctx._wrapped)(function() {
        var ctx = this.ctx;
        ctx._wrapped=true;
        applyCtx({ block: 'b-wrapper', content: ctx })
   })


```

Для избежания бесконечного цикла необходимо при вызове выражения `applyCtx()` проверять наличие в контексте специального
флага (`_wrap`), который будет выставлен при выполнении `applyCtx()`.


***
**NB** Конструкцию `applyCtx()` можно применять для **замены** БЭМ-сущности в исходном дереве, если не использовать
исходное содержимое блока (`this.ctx`) в аргументе `applyCtx()`.
***

**См. также**:

  * [Конструкция applyCtx](../templating/template.ru.md#applyctx)

<a name="additionbem"></a>

#### Добавление БЭМ-сущностей для задач вёрстки

##### Задача

Необходимо сверстать блок с закруглёнными уголками, работающий во всех браузерах (без использования CSS3).

Входной BEMJSON может быть таким:

```js
{ block: 'box', content: 'text' }
```

Реализация уголков требует добавления к блоку четырех дополнительных элементов. Поскольку данные элементы отражают
детали HTML-верстки, ими не следует загромождать входное БЭМ-дерево. Добавить эти элементы следует на уровне
BEMHTML-шаблона. Финальное БЭМ-дерево должно выглядеть так:

```js
{
    block: 'box',
    content: {
        elem: 'left-top',
        content: {
            elem: 'right-top',
            content: {
                elem: 'right-bottom',
                content: {
                    elem: 'left-bottom',
                    content: 'text'
                }
            }
        }
    }
}
```


##### Решение

Для модификации входного БЭМ-дерева на уровне BEMHTML потребуется написать шаблон по моде `content` для блока `box`.
Подмена фрагмента входного БЭМ-дерева (добавление необходимых элементов) выполняется с помощью конструкции `applyCtx()`,
а подстановка исходного содержимого — с помощью конструкции `applyNext()`.

BEMHTML-шаблон, выполняющий это преобразование:

```js
block('box').match(!this.ctx._processed).content()(applyCtx({'ctx._processed':true}, {
    elem: 'left-top',
    content: {
        elem: 'right-top',
        content: {
            elem: 'right-bottom',
            content: {
                elem: 'left-bottom',
                content: applyNext()
            }
        }
    }
}))
```

**NB:** Хеш с переменной `ctx._processed` в значении `true` передается методу `applyCtx` первым параметром, чтобы выполнить метод в модифицированном контексте.



**См. также**:

  * [Конструкция apply](../templating/template.ru.md#apply)
  * [Конструкция applyNext](../templating/template.ru.md#applynext)
  * [Конструкция applyCtx](../templating/template.ru.md#applyctx)

<a name="use_bem"></a>

#### Использование позиции БЭМ-сущности

##### Задача

Необходимо пронумеровать пункты меню, начиная с 1. В текст каждого элемента меню нужно добавить его порядковый номер
с точкой.

##### Решение

Используем механизм вычисления позиции БЭМ-сущности среди сиблингов (поле контекста `this.position`).
Входные данные могут выглядеть так:

```js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'aaa' },
    { elem: 'item', content: 'bbb' },
    { elem: 'item', content: 'ccc' }
  ]
}
```

Для выполнения нумерации следует написать шаблон по моде `content` на пункт меню, в котором содержание элемента будет
составлено из номера позиции, разделителя (точки с пробелом) и исходного текста элемента (полученного с помощью
конструкции `applyNext()`):

```js
block('menu')(
  tag()('ul'),
  elemMatch('item')(
    tag()('li'),
    content()([
      this.position, '. ',
      applyNext()
    ]
  )
))
```

**См. также**:

  * [Мода content](#content)
  * [Конструкция applyNext](../templating/template.ru.md#applynext)

<a name="check_predicate"></a>

#### Проверка подпредикатов в определенном порядке

##### Задача

Необходимо проверять подпредикаты шаблона в строго определенном порядке, например, сначала проверить наличие в контексте
объекта `this.world`, а затем проверить значение поля в этом объекте `this.world.answer`.

##### Решение

Воспользуемся тем, что подпредикат шаблона BEMHTML может быть произвольным JavaScript-выражением и запишем его
в следующей форме:

```js
match(this.world && this.world.answer === 42)
```

Недостаток этого решения в том, что при компиляции это выражение не будет оптимизировано, что отрицательно скажется
на скорости работы шаблона. В большинстве случаев можно и нужно избегать необходимости в строгом порядке проверки
подпредикатов.

<a name="binding_html"></a>

#### Связывание HTML-элементов по id

##### Задача

Необходимо для входного блока `input` сгенерировать пару HTML-элементов `<label>` и `<input>`, так чтобы значение
атрибута `input@id` было сгенерировано автоматически, уникально и совпадало со значением атрибута `label@for`.

Входные данные могут выглядеть так:

```js
{
  block: 'input',
  label: 'My Input',
  content: 'my value'
}
```

##### Решение

Для генерации уникального идентификатора, подходящего в качестве значения атрибута `id`, воспользуемся вспомогательной
функцией контекста `this.generateId()`. Чтобы сгенерировать два HTML-элемента на основании одного входного блока, потребуется два шаблона:

  * шаблон по моде `tag`, указывающий пустую строку, чтобы отменить генерацию HTML-элемента для данного блока,
    но обработать содержимое;
  * шаблон по моде `content`, в котором будут сформированы два необходимых элемента и их атрибуты.

```js
block('input')(
  tag()(''),
  content()([
    {
      tag: 'label',
      attrs: { 'for': this.generateId() },
      content: this.ctx.label
    },
    {
      tag: 'input',
      attrs: {
        id: this.generateId(),
        value: this.ctx.content
      }
    }
  ]
))
```



