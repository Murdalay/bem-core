<a id="intro"></a>

### Введение

**Данный документ** представляет собой справочное руководство по формату описания входных данных BEMJSON.

В документе описаны:

* основные особенности BEMJSON, отличающие его от других форматов;
* синтаксис описания входных данных BEMJSON и шаблонов BEMHTML;


**Целевая аудитория документа** — веб-разработчики и HTML-верстальщики, использующие
[БЭМ-методологию](http://ru.bem.info/method/).

Предполагается, что читатель знаком с:

* HTML;
* JavaScript;
* CSS;
* БЭМ.


**В документе не описаны** средства гененерации БЭМ-дерева в формате BEMJSON.


###Общие понятия

###BEMJSON и шаблонизация в bem-core


<a name="bemjson"></a>

### Синтаксис BEMJSON

<a id="datatype"></a>

#### Типы данных

Типы данных в BEMJSON аналогичны соответствующим типам в JavaScript.

* Строки и числа:
 * **Строка** `` 'a' `` `"a"`;
 * **Число** `1` `0.1`;

   Структура данных, состоящая из строки или числа, является валидным BEMJSON.

* **Объект** (ассоциативный массив) '{ключ: значение}' и остальные типы, кроме массива.

* **Массив** — список, может содержать элементы различных типов (строки, числа, объекты, массивы)
  `[ "a", 1, {ключ: значение}, [ "b", 2, ... ] ]`.

<a id="fields_bemjson"></a>

#### Специальные поля BEMJSON

Для представления данных предметной области БЭМ и HTML в BEMJSON используются объекты, в которых зарезервированы
специальные имена полей.

<a name="notionbem"></a>

#####Представление БЭМ-сущностей

БЭМ-сущности представляются в BEMJSON в виде объектов, в которых могут присутствовать следующие поля:

<table>
<tr>
    <th>Поле</th>
    <th>Значение</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>block</code></td>
    <td>Имя блока</td>
    <td>Строка</td>
    <td><code>{ block: 'b-menu' }</code></td>
</tr>

<tr>
    <td><code>elem</code></td>
    <td>Имя элемента</td>
    <td>Строка</td>
    <td><code>{ elem: 'item' }</code></td>
</tr>

<tr>
    <td><code>mods</code></td>
    <td>Модификаторы блока</td>
    <td>Объект, содержащий имена и значения модификаторов в качестве пар ключ-значение:
        <code>{имя_модификатора: 'значение_модификатора'}</code>
    </td>
    <td>
        <pre><code>
{
  block: 'b-link',
  mods: { pseudo: 'yes', color: 'green' }
}
        </code></pre>
    </td>
</tr>

<tr>
    <td><code>elemMods</code></td>
    <td>Модификаторы элемента</td>
    <td>Объект, содержащий имена и значения модификаторов элемента в качестве пар ключ-значение:
        <code>{имя_модификатора: 'значение_модификатора'}</code>
    </td>
    <td>
        <pre><code>
{
  elem: 'item',
  elemMods: { selected: 'yes' }
}
        </code></pre>
    </td>
</tr>

<tr>
    <td><code>mix</code></td>
    <td>Подмешанные блоки/элементы</td>
    <td>Массив, содержащий объекты, описывающие подмешанные блоки и элементы. В качестве значения может выступать
    объект, который трактуется как массив, состоящий из одного элемента.</td>
    <td>
        <pre><code>
{
  block: 'b-link',
  mix: [ { block: 'b-serp-item', elem: 'link' } ]
}
        </code></pre>
    </td>
</tr>
</table>

**См. также**:

* [Достраивание БЭМ-сущностей по контексту](#extensionbem)

<a name="notionhtml"></a>

##### Представление HTML

BEMJSON предоставляет возможность задавать некоторые аспекты выходного HTML непосредственно во входных данных.
Этой возможностью не следует злоупотреблять, т.к. BEMJSON представляет собой уровень данных, а непосредственное
оформление HTML должно выполняться на уровне шаблонизатора (BEMHTML). Однако возможны ситуации, где оправданно
описание HTML-представления на уровне BEMJSON. В этом случае автор шаблонов BEMHTML должен понимать, каким образом
параметры HTML, заданные входными данными, взаимодействуют с HTML-представлением, определенным на уровне шаблонов.

В BEMJSON предусмотрены следующие поля для непосредственного управления HTML-представлением:

<table>
<tr>
    <th>Поле</th>
    <th>Значение</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>tag</code></td>
    <td>HTML-тег для данной сущности</td>
    <td><code>String</code></td>
    <td>
        <pre><code>{
  block: 'b-my-block',
  tag: 'img'
}</code></pre>
    </td>
</tr>
<tr>
    <td><code>attrs</code></td>
    <td>HTML-атрибуты для данной сущности</td>
    <td><code>Object</code></td>
    <td>
        <pre><code>{
  block: 'b-my-block',
  tag: 'img',
  attrs: { src: '//yandex.ru/favicon.ico', alt: '' }
}</code></pre>
    </td>
</tr>
<tr>
    <td><code>cls</code></td>
    <td>Строка, добавляемая к HTML-атрибуту <code>class</code> (помимо автоматически генерируемых классов)</td>
    <td><code>String</code></td>
    <td>
        <pre><code>{
  block: 'b-my-block',
  cls: 'some-blah-class'
}</code></pre>
    </td>
</tr>
<tr>
    <td><code>bem</code></td>
    <td>Флаг — отменить генерацию БЭМ-классов в HTML-атрибуте <code>class</code> для данной сущности </td>
    <td><code>Boolean</code></td>
    <td>
        <pre><code>{
  block: 'b-page',
  tag: 'html',
  bem: false
}</code></pre>
    </td>
</tr>
<tr>
    <td><code>js</code></td>
    <td>Либо флаг о наличии клиентского JavaScript у данной сущности, либо параметры JavaScript</td>
    <td><code>Boolean</code></td>
    <td>
        <pre><code>{
  block: 'b-form-input',
  mods: { autocomplete: 'yes' },
  js: {
    dataprovider: { url: 'http://suggest.yandex.ru/...' }
  }
}</code></pre>
    </td>
</tr>
</table>

Обратите внимание, что имена и смысл полей BEMJSON, управляющих HTML-представлением, совпадают с именами и смыслом соответствующих [стандартных мод](#standardmoda) BEMHTML (тег, атрибуты, класс и т.п.). В случае, если какие-то из аспектов выходного HTML заданы **и во входных данных, и в BEMHTML-шаблонах**, то более высокий приоритет имеют значения, заданные в BEMHTML-шаблонах.

При генерации HTML будет выполнено одно из двух действий:

* **Объединение** значений HTML-параметров, заданных в BEMJSON, cо значениями параметров, заданных в BEMHTML-шаблоне. Объединение значений производится только для тех параметров, для которых оно имеет очевидный смысл: `attrs`, `js`, `mix`.
* **Замещение** значений HTML-параметров, заданных в BEMJSON, значениями, заданными в **BEMHTML-шаблоне**. Выполняется для всех прочих значений: `tag`, `cls`, `bem`, `content`.

***
**NB** Приоритет BEMHTML-шаблонов позволяет **автору шаблонов** принимать решение, какие HTML-параметры будут приоритетнее в каждом конкретном случае — заданные в BEMHTML или в BEMJSON. Значения HTML-параметров, заданных в BEMJSON, доступны в шаблонах при обращении к фрагменту входного BEMJSON-дерева в контексте (поле `this.ctx`).
***

<a name="nesting"></a>

##### Вложенность: content

Для представления вложенных БЭМ-сущностей (БЭМ-дерева) в BEMJSON зарезервировано поле `content`. В качестве значения
данного поля может выступать произвольный BEMJSON:

* Примитивный тип (строка, число). Значение используется в качестве содержимого (текста) HTML-элемента, соответствующего
  контекстной сущности.
* Объект, описывающий БЭМ-дерево. Значение используется для генерации HTML-элементов, вложенных в HTML-элемент,
  соответствующий контекстной сущности.

Уровень вложенности дерева БЭМ-сущностей, построенного с помощью поля `content`, не ограничен.

**См. также**:

* [Мода content](#content)

<a id="custom_fields"></a>

##### Произвольные поля

Помимо специальных полей, описывающих БЭМ-сущность и ее HTML-представление, в том же объекте могут присутствовать
любые поля с произвольными данными, которые будут доступны для использования в BEMHTML-шаблонах.

Примером произвольного поля может служить поле `url` в блоке ссылки:

```js
{
  block: 'b-link',
  url: '//yandex.ru'
}
```

Пример использования данных из произвольного поля см. в разделе: [Выбор шаблона по условию](#select_template).

<a name="customjs"></a>

#### Произвольный JavaScript в BEMJSON

BEMJSON является менее ограниченным форматом, чем JSON. Произвольные JavaScript-выражения будут валидным BEMJSON.

Специфика BEMJSON как формата данных заключается в соблюдении описанных в предшествующих разделах соглашений
по именованию полей в объектах (для представления БЭМ-сущностей и HTML-представления) и правил вложения объектов.